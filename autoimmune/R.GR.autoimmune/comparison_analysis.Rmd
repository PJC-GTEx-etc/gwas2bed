---
title: "Comarison of manually classified diseases"
author: "Mikhail G. Dozmorov"
date: "March 29, 2015"
output: html_document
---

```{r setup, echo=FALSE, message=FALSE}
source("../../../../GenomeRunner/R.GenomeRunner/utils1.R")
# Set up the environment
library(knitr) 
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=F, tidy=T, fig.keep='high', echo=F, dpi=100, warnings=F, message=F, comment=NA, warning=F) #out.width=700, 
options(replace.assign=TRUE, stringsAsFactors = FALSE)#, width=120)
suppressMessages(library(pander))
panderOptions('table.split.table', Inf)
set.seed(1)
```

```{r localFunctions}
#' Reshape wide format data
#'
#' A function to reshape wide data format removing self-self and duplicated reverse associations
#'
#' @param mtx a matrix, in wide format. First column is the 'id.var'
#'
#' @return a matrix in long format, with self-self and duplicate associations removed
#' @export
#' @examples
#' reshape_wide_data(mtx)
##
reshape_wide_data <- function(mtx) {
  mtx <- mtx[ order(rownames(mtx)), order(colnames(mtx))]
  mtx[ lower.tri(mtx, diag=TRUE) ] <- NaN # Set lower portion to NaN, including the diagonal
  mtx <- melt(mtx) # Melt, and remove Nan associations
  mtx <- mtx[ !is.nan(mtx$value), ]
  rownames(mtx) <- paste(mtx$Var1, mtx$Var2, sep="_")
  mtx <- mtx[, 3, drop=F]
  return(mtx)
}

library(xlsx)
# Load term mapping
term.mapping <- read.xlsx2("data/icd9_mapping.xlsx", sheetName="manual")

# Correlation to use
cortype <- "spearman"
```

```{r diseaseNetwork1, echo=FALSE, cache=FALSE, eval=TRUE}
# # All disease-disease relationships
# mtx.disease <- readRDS("/Users/mikhail/Documents/Work/GenomeRunner/Paper-Similarity/data_gwasCatalog/AllNet5/AllNet5.Rds") # Full Barabasi matrix
# # Optionally, use 3-digits IDC9 codes
# # mtx.disease <- read.table("../../AllNet3.net", sep="\t", header=F)
# # Subset by ICD9 codes associated with terms
# mtx.disease <- mtx.disease[ mtx.disease$V1 %in% term.mapping$ICD9[ term.mapping$ICD9 != "" ] & mtx.disease$V2 %in% term.mapping$ICD9[ term.mapping$ICD9 != ""], ]
# 
# # Create empty matrix of term disease-disease relationships ($V5 - co-occurrence)
# term.ICD9.occur <- matrix(NA, nrow=nrow(term.mapping), ncol=nrow(term.mapping))
# rownames(term.ICD9.occur) <- term.mapping$Name
# colnames(term.ICD9.occur) <- term.mapping$Name
# # Create two others, to hold relative risk ($V6) and phi-correlation ($V9)
# term.ICD9.risk <- term.ICD9.occur; term.ICD9.phi <- term.ICD9.occur
# 
# # Populate this matrix with Barabasi relationship values
# for (i in 1:nrow(term.mapping)) {
#   for (j in 1:nrow(term.mapping)) {
#     if(term.mapping$ICD9[i] != "" & term.mapping$ICD9[j] != "") {
#       # The disease associations matrix is not symmetrical - we pull up the index with either disease1-disease2 relationship, or disease2-disease1 relationship
#       idx <- (mtx.disease$V1 == term.mapping$ICD9[i] & mtx.disease$V2 == term.mapping$ICD9[j]) | (mtx.disease$V2 == term.mapping$ICD9[i] & mtx.disease$V1 == term.mapping$ICD9[j])
#       # If relationship pair is found, store it. Self-self relationships will be 0
#       term.ICD9.occur[i, j] <- max(mtx.disease$V5[idx])
#       term.ICD9.risk[i, j] <- max(mtx.disease$V6[idx])
#       term.ICD9.phi[i, j] <- max(mtx.disease$V9[idx])
#     }
#   }
#   # If self-self relationship is -Inf, replace it with maximum existing
#   term.ICD9.occur[i, i] <- max(term.ICD9.occur[i, ], na.omit=T)
#   term.ICD9.risk[i, i] <- max(term.ICD9.risk[i, ], na.omit=T)
#   term.ICD9.phi[i, i] <- max(term.ICD9.phi[i, ], na.omit=T)
# }
# # Replace infinite by NAs
# term.ICD9.occur[ is.infinite(term.ICD9.occur) ] <- NA
# term.ICD9.phi[ is.infinite(term.ICD9.phi) ] <- NA
# term.ICD9.risk[ is.infinite(term.ICD9.risk) ] <- NA
# # Reformat the data
# term.ICD9.occur <- reshape_wide_data(term.ICD9.occur)
# term.ICD9.phi <- reshape_wide_data(term.ICD9.phi)
# term.ICD9.risk <- reshape_wide_data(term.ICD9.risk)
# # Save the data
# saveRDS(term.ICD9.occur, "data/term.ICD9.3.occur.Rds")
# saveRDS(term.ICD9.phi, "data/term.ICD9.3.phi.Rds")
# saveRDS(term.ICD9.risk, "data/term.ICD9.3.risk.Rds")
# Read in saved objects, ICD9 5-digits
term.ICD9.occur <- readRDS("data/term.ICD9.occur.Rds")
term.ICD9.phi <- readRDS("data/term.ICD9.phi.Rds")
term.ICD9.risk <- readRDS("data/term.ICD9.risk.Rds")
# # Read in saved objects, ICD9 3-digits
# term.ICD9.occur <- readRDS("data/term.ICD9.3.occur.Rds")
# term.ICD9.phi <- readRDS("data/term.ICD9.3.phi.Rds")
# term.ICD9.risk <- readRDS("data/term.ICD9.3.risk.Rds")

```

Preparing disease ontology similarity

```{r eval=FALSE}
library(DOSE)
# # Validating some associations manually
# xx <- as.list(DOTERM)
# xx.term <- Term(names(xx))
# xx.term[ grepl("testicular", xx.term) ]
# xx.term[ grepl("testicular", xx.term, ignore.case=TRUE) & grepl("tumor", xx.term, ignore.case=TRUE)]
# xx.term["DOID:5419"]

dose.select <- function(measure="Wang"){
  tmp <- doSim(term.mapping$DOID[ term.mapping$DOID != "" ], term.mapping$DOID[ term.mapping$DOID != "" ], measure = measure) # "Wang", "Resnik", "Rel", "Jiang", and "Lin"
  rownames(tmp) <- term.mapping$Name[ term.mapping$DOID != "" ]
  colnames(tmp) <- term.mapping$Name[!(term.mapping$DOID == "")]
  return(reshape_wide_data(tmp))
}
dose.wang <- dose.select("Wang")
dose.resnik <- dose.select("Resnik")
dose.rel <- dose.select("Rel")
dose.jiang <- dose.select("Jiang")
dose.lin <- dose.select("Lin")
```

Loading genomic jaccard similarity

```{r}
mtx <- as.matrix(read.table("data/jaccard.autoimmune.wide.txt", sep="\t", header=T, row.names=1, stringsAsFactors=F))
mtx <- mtx[rownames(mtx) %in% term.mapping$Name, colnames(mtx) %in% term.mapping$Name] 
mtx.jaccard <- reshape_wide_data(mtx)
```

Preparing Bridget similarity

```{r}
read.Bridget <- function(fname){
  mtx <- read.table(fname, sep="\t", stringsAsFactors = FALSE)
  tmp <- dcast(mtx, V1 ~ V2, value.var="V3", mean)
  rownames(tmp) <- tmp$V1
  tmp$V1 <- NULL
  return(reshape_wide_data(as.matrix(tmp)))
}
term.msh.path <- read.Bridget("data/terms.msh.path.txt")
term.snomed.path <- read.Bridget("data/terms.snomed.path.txt")
term.snomed.vector <- read.Bridget("data/terms.snomed.vector.txt")
term.iridescent.minMim <- read.Bridget("data/iridescent.minMim.txt")
term.iridescent.misn <- read.Bridget("data/iridescent.misn.txt")
term.iridescent.obsExp <- read.Bridget("data/iridescent.obsExp.txt")
term.iridescent.relOverlap <- read.Bridget("data/iridescent.relOverlap.txt")
term.iridescent.sharedRels <- read.Bridget("data/iridescent.sharedRels.txt")
```


Loading Farh clustering

```{r eval=FALSE}
mtx.fig1a <- as.matrix(read.table("data/fig1a_matrix", sep="\t", header=F, stringsAsFactors=F))
labels.fig1a <- readLines("data/fig1a_labels")
colnames(mtx.fig1a) <- labels.fig1a
rownames(mtx.fig1a) <- labels.fig1a
mtx.fig1a <- reshape_wide_data(mtx.fig1a)
```

Combining with episimilarity

```{r}
# Merge previously prepared matrixes
mtx.list.epi <- c(list(mtx.fig1a), list(mtx.jaccard), list(term.ICD9.occur), list(term.ICD9.phi), list(term.ICD9.risk), list(term.msh.path), list(term.snomed.path), list(term.snomed.vector), list(term.iridescent.minMim), list(term.iridescent.misn), list(term.iridescent.obsExp), list(term.iridescent.relOverlap), list(term.iridescent.sharedRels), list(dose.jiang), list(dose.lin), list(dose.rel), list(dose.resnik), list(dose.wang))
#, list(mtx.clusterSim.MF.Resnik), list(mtx.clusterSim.MF.Wang))
mtx.cor.epi.joined <- do.call(cbind, lapply(mtx.list.epi, function(x) x[match(rownames(mtx.list.epi[[1]]), rownames(x)), ]))
rownames(mtx.cor.epi.joined) <- rownames(mtx.list.epi[[1]])

# # Another merging method
# # https://stackoverflow.com/questions/16666643/merging-more-than-2-dataframes-in-r-by-rownames
# MyMerge       <- function(x, y){
#   df            <- merge(x, y, by= "row.names", all.x= F, all.y= F)
#   rownames(df)  <- df$Row.names
#   df$Row.names  <- NULL
#   return(df)
# }
# colnames(mtx.jaccard) <- "jaccard"
# colnames(term.ICD9.occur) <- "occur"
# colnames(term.ICD9.phi) <- "phi"
# colnames(term.ICD9.risk) <- "risk"
# mtx.cor.epi.joined <- Reduce(MyMerge, list(mtx.jaccard, term.ICD9.occur, term.ICD9.phi, term.ICD9.risk))
# mtx.cor.epi.joined <- MyMerge(mtx.jaccard, term.ICD9.occur)
# mtx.cor.epi.joined <- MyMerge(mtx.cor.epi.joined, term.ICD9.phi)
# mtx.cor.epi.joined <- MyMerge(mtx.cor.epi.joined, term.ICD9.risk)
# 
# mtx.cor.epi.joined <- plyr::join_all(list(cbind(rn=rownames(mtx.jaccard), mtx.jaccard),
#                                           cbind(rn=rownames(term.ICD9.occur), term.ICD9.occur),
#                                           cbind(rn=rownames(term.ICD9.phi), term.ICD9.phi),
#                                           cbind(rn=rownames(term.ICD9.risk), term.ICD9.risk)),
#                                      by = 'rn', type = "full")


# Add (combinations of) GenomeRunner's results
dname <- list("data.gr/ENCODE_Dgf/matrix_PVAL.txt",
           "data.gr/ENCODE_Dnase/matrix_PVAL.txt",
           "data.gr/ENCODE_Histone/matrix_PVAL.txt",
           "data.gr/ENCODE_Tfbs/matrix_PVAL.txt",
           "data.gr/Roadmap_broadPeak/matrix_PVAL.txt",
           "data.gr/Roadmap_DNase_hotspot01/matrix_PVAL.txt",
           "data.gr/Roadmap_DNase_hotspotall/matrix_PVAL.txt",
           "data.gr/Roadmap_DNase_hotspotbroad01/matrix_PVAL.txt",
           "data.gr/Roadmap_DNase_hotspotbroadall/matrix_PVAL.txt",
           "data.gr/Roadmap_DNase_narrowPeak/matrix_PVAL.txt",
           "data.gr/Roadmap_gappedPeak/matrix_PVAL.txt",
           "data.gr/Roadmap_narrowPeak/matrix_PVAL.txt",
           "data.gr/Roadmap_chromStates18/matrix_PVAL.txt",
           c("data.gr/ENCODE_Dgf/matrix_PVAL.txt", "data.gr/ENCODE_Dnase/matrix_PVAL.txt", "data.gr/ENCODE_Histone/matrix_PVAL.txt", "data.gr/ENCODE_Tfbs/matrix_PVAL.txt"), 
           "data.gr/ENCODE_FDR/matrix.txt",
           c("data.gr/Roadmap_broadPeak/matrix_PVAL.txt", "data.gr/Roadmap_DNase_hotspot01/matrix_PVAL.txt", "data.gr/Roadmap_DNase_hotspotall/matrix_PVAL.txt", "data.gr/Roadmap_DNase_hotspotbroad01/matrix_PVAL.txt", "data.gr/Roadmap_DNase_hotspotbroadall/matrix_PVAL.txt", "data.gr/Roadmap_DNase_narrowPeak/matrix_PVAL.txt", "data.gr/Roadmap_gappedPeak/matrix_PVAL.txt", "data.gr/Roadmap_narrowPeak/matrix_PVAL.txt", "data.gr/Roadmap_chromStates18/matrix_PVAL.txt")
           )

# library(minerva) # Playing with MIC correlation coefficient
# Read in data in a loop
for (x in dname) {
  mtx <- load_gr_data(x)
  mtx <- mtx[, colnames(mtx) %in% term.mapping$Name] 
  mtx.cor <- rcorr(mtx, type=cortype)[[1]]
  # mtx.cor <- mine(mtx, n.cores=4)$MIC
  mtx.cor.long <- reshape_wide_data(mtx.cor)
  mtx.cor.epi.joined <- cbind(mtx.cor.epi.joined, mtx.cor.long[match(rownames(mtx.cor.epi.joined), rownames(mtx.cor.long)), ])
}

# Set the column names after merging lists
colnames(mtx.cor.epi.joined) <- c("Farh", "jaccard", "occur", "phi", "risk", "msh.path", "snomed.path", "snomed.vector", "iridescent.minMim", "iridescent.misn", "iridescent.obsExp", "iridescent.relOverlap", "iridescent.sharedRels", "dose.jiang", "dose.lin", "dose.rel", "dose.resnik", "dose.wang", "Encode.Dgf", "Encode.Dnase", "Encode.Histone", "Encode.Tfbs", "Roadmap.broadPeak", "Roadmap.Dnase.hotspot01", "Roadmap.Dnase.hotspotall", "Roadmap.Dnase.hotspotbroad01", "Roadmap.Dnase.hotspotbroadall", "Roadmap.Dnase.narrowPeak", "Roadmap.gappedPeak", "Roadmap.narrowPeak", "Roadmap.chromStates18", "Encode.combined", "Encode.FDR", "Roadmap.combined")
#  "dose.jiang", "dose.lin", "dose.rel", "dose.resnik", "dose.wang", "sim.MF.Resnik", "sim.MF.Wang",
```

```{r eval=FALSE}
# Visualize distributions
#mtx.cor.epi.joined <- normalizeQuantiles()
ggplot(melt(mtx.cor.epi.joined), aes(x=Var2, y=value, fill=Var2)) + 
  geom_boxplot() + 
  coord_cartesian(ylim = c(-1, 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1))
```

Summarize all, and most correlated with episimilarity metrics. Visualize it as a heatmap

```{r similarityHeatmap_gwasCatalog, fig.height=9, fig.width=13, dev="png"}
mtx.summary <- rcorr(as.matrix(mtx.cor.epi.joined), type=cortype)[[1]]
pander(mtx.summary)

par(oma=c(5,0,0,5), mar=c(10, 4.1, 4.1, 5), cex.main=0.65) # Adjust margins
my_col <- colorRampPalette(c("blue", "white", "red"))
#my_col <- greenred
heatmap.2(mtx.summary, trace="none", density.info="none", col=color, distfun=function(x){dist(x, method=dist.method)}, hclustfun=function(x){hclust(x, method=hclust.method)}, cellnote=formatC(mtx.summary, format="f", digits=2), notecol="black", notecex=1)
```



